## Q15. 힙 영역과 스택영역의 차이점을 설명하시오.

**스택은 정적 메모리**를, **힙은 동적 메모리**를 저장하는 영역.
**스택은 함수,지역변수,매개변수**가 저장되며 **LIFO 방식**으로 관리되지만 **힙 영역은 전역 변수**를 다루며 **사용자가 직접 관리**해야 하는 메모리 영역이다.



### 스택

> **장점**
>
> - 매우 빠른 액세스(할당,해제가 빠르다)
> - 변수를 명시적으로 할당 해제 할 필요가 없다.
>
> **단점**
>
> - 메모리 크기 제한
> - 지역 변수만



### 힙

> **장점**
>
> - 변수는 전역적으로 액세스 할 수 있다.
> - 메모리 크기 제한이 없다.
>
> **단점**
>
> - 상대적으로 느린 액세스(할당,해제가 느리다)
> - 메모리를 관리해야 한다.(변수를 할당하고 해제하는 책임이 있다)
> - 운영체제마다 메모리 관리가 다르기 때문에 어렵다.





## Q11 페이징과 세그멘테이션에 대해 설명해주세요.

### 🔎 페이징

논리주소의 메모리를 고정된 크기의 페이지(Page)로 나누어 관리하는 기법.

<img src="https://blog.kakaocdn.net/dn/HNKio/btrnyI3uXYF/5B8HR1lwrFO0FOZdK1f3k0/img.png" alt="페이징" style="zoom: 80%;" />



#### 특징

- 물리주소 공간(Physical address)은 연속적이지 않을 수 있다.(noncontiguous)

- 페이지는 모두 같은 크기.

- 물리주소 공간을 페이지와 같은 사이즈로 나눈 것들을 프레임(Frame)이라고 한다.

- 페이지 사이즈(=프레임 사이즈)는 하드웨어에 의해 정해진다.

- 페이지의 크기는 일반적으로 2의 제곱수를 사용한다. 일반적으로 4KB(2^12) ~ 1GB(2^20) 

- **페이지 테이블(page table)을 이용해 논리주소에서 프레임을 가리키는 물리주소로 매핑한다.**

  > **page table**
  >
  > 논리주소의 페이지를 물리주소의 프레임으로 매핑시켜주는 정보를 담고 있는 테이블

- **외부 단편화는 발생하지 않으나, 내부 단편화는 발생한다.**



### 🔎 세그멘테이션

프로세스를 **논리적 내용을 기반으로 나눠서** 메모리에 배치하는 것.

세그멘테이션은 프로세스를 세그먼트(segment)의 집합으로 표현한다. 프로세스를 code영역, data영역, stack영역 등으로 나누는 것 또한 세그멘테이션이라고 할 수 있다.

<img src="https://blog.kakaocdn.net/dn/ol2eM/btrnC38FGmG/Kv5nbXQG2rCUeck0pRS8I0/img.png" alt="세그멘테이션 테이블" style="zoom:67%;" />

세그멘테이션도 페이징과 비슷하게 세그먼트 테이블을 가지고 있다. (논리주소 : <segment-number, offset>)

페이징 테이블과 다른점은 **세그먼트의 크기가 일정하지 않기 때문에,** 테이블에 **limit 정보**가 추가로 들어있다.

만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 해당 프로세스는 강제 종료된다.



### ⚠️ 페이징 vs 세그멘테이션

세그멘테이션은 페이징보다 보호와 공유 면에서 더 낫다. 

세그멘테이션은 read/write/execute 권한을 테이블에 추가하는데, 이때 이것을 논리적으로 나누기 때문에 해당 비트를 설정하기 간단하고 안전하다. 

반면, 페이징은 code+data+stack 영역이 존재할 때 이를 일정한 크기로 나누기 때문에 **영역이 섞여 비트를 설정하기 까다로워**질 수 있다.  

공유의 측면에서도 마찬가지로, 페이징은 영역이 섞일 가능성이 존재하지만, 세그멘테이션은 정확히 영역을 나누므로 더 효율적으로 공유를 할 수 있다.

 

**하지만, 현재 대부분 페이징 기법을 세그멘테이션보다 많이 사용한다.**

**why?** 세그멘테이션의 세그먼트 크기가 일정하지 않고 다양하기 때문. 세그먼트의 크기가 다양하기 때문에 다양한 hole이 발생해 **외부단편화**(external fragmentation)가 발생하여 메모리 낭비가 크게 된다. 



참고)

https://code-lab1.tistory.com/55

https://code-lab1.tistory.com/57