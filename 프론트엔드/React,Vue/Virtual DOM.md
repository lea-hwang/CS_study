# Virtual DOM

## 🔎 DOM

- *웹 페이지나 웹 앱에 있는 HTML 요소들을 구조적으로 표현한 것.*

- DOM은 **애플리케이션의 전체 UI**를 나타내며 **트리 데이터 구조**로 표현된다. 여기에는 Web Document에 있는 각 UI 요소에 대한 노드가 포함된다. 
- 웹 개발자가 JavaScript를 통해 콘텐츠를 수정할 수 있기 때문에 매우 유용하다.
- 구조화된 형식으로 되어 있어 특정 대상을 선택할 수 있고, 모든 코드 작업이 훨씬 쉬워지기 때문에 많은 도움이 된다.



### DOM의 문제점

- DOM은 트리 구조로 되어 있어서 이해하기 쉽지만, **노드의 수가 많아질수록 속도가 느려지고 DOM 업데이트에 잦은 오류를 발생시킬 수 있다.**
- 또한, 최근 모던 웹은 SPA(Single Page Application)을 사용한다. 하나의 웹 페이지를 어플리케이션처럼 구성하는 SPA에서는 *HTML문서 자체가 하나*이며, *여러 동적인 기능이 들어가기* 때문에 안그래도 리소스가 모두 합쳐진 *무거운 HTML문서를 지속적으로 재랜더링 해줘야한다*는 문제점이 발생하게 되었다.
- JavaScript의 "getElementById()"또는 "getElementByClass()"메서드를 사용하여 DOM의 내용을 수정할 수 있다.

```js
document.getElementById('some-id').innerValue = 'updated value';
```

- 콘솔이나 JavaScript 파일에 위와 같은 코드가 실행 될 때 아래의 과정이 일어나게 된다.

  1. 브라우저는 HTML을 구문 분석하여 이 ID를 가진 노드를 찾는다.

  2. 이 특정 요소의 자식 요소를 제거한다.
  3. 'updated value'로 요소(DOM)을 업데이트 한다.
  4. 부모 및 자식 노드에 대한 CSS를 다시 계산한다.
  5. 마지막으로 브라우저 디스플레이에 페인팅 된다.

따라서 *DOM을 업데이트하는 것은* 콘텐츠 변경을 포함할 뿐만이 아니라 *훨씬 더 많은 작업들이 요구된다.* 또한 CSS를 다시 계산하고 레이아웃을 변경하려면 복잡한 알고리즘이 필요하며 *성능에 영향을 미치게 된다.*

이처럼 기존에는 화면의 변경사항을 DOM을 직접 조작하여 브라우저에 반영하였다. 하지만 이 방법의 **가장 큰 단점은 DOM 트리가 수정될 때마다 렌더 트리가 계속해서 실시간으로 갱신된다는 점이다.** 즉, 화면에서 10개의 수정사항이 발생하면 수정할 때마다 새로운 랜터트리가 10번 수정되면서 새롭게 만들어지게 되는 것이다.



## 🔎 브라우저의 Workflow

참고) Webkit 엔진

![img](https://velopert.com/wp-content/uploads/2017/03/wvbwscn7oadykroobdd3.png)

### DOM Tree 생성

브라우저가 HTML 을 전달받으면, 브라우저의 렌더 엔진이 이를 파싱하고 DOM 노드(Node) 로 이뤄진 트리를 만든다. 각 노드는 각 HTML 엘리먼트들과 연관되어있다.

 

### Render Tree 생성

그리고 외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱한다. 스타일 정보를 사용하여 DOM 트리에 따라 새로운 트리, 렌더트리를 만든다.

 

### Render Tree 생성 – 그 뒤에선 무슨일이 일어나고 있는가..?

Webkit 에서는 노드의 스타일을 처리하는 과정을 ‘attachment’ 라고 부른. DOM 트리의 모든 노드들은 ‘attach’ 라는 메소드가 있다. 이 메소드는 *스타일 정보를 계산해서 객체형태로 반환*한다.

이 과정은 동기적(synchronous) 작업이다. DOM 트리에 새로운 노드가 추가되면 그 노드의 attach 메소드가 실행된다.

렌더 트리를 만드는 과정에선, 각 요소들의 스타일이 계산된다. 또, 이 계산되는 과정에서 다른 요소들의 스타일 속성들을 참조한다.

 

### Layout (reflow)

렌더 트리가 다 만들어지고 나면, 레이아웃 과정을 거친다. 각 노드들은 스크린의 좌표가 주어지고, 정확히 어디에 나타나야 할 지 위치가 주어진다.

 

### Painting

그 다음 작업은 렌더링 된 요소들에 색을 입히는 과정이다. 트리의 각 노드들을 거쳐가면서 paint() 메소드를 호출한다. 그러고나면, 스크린에 원하는 정보가 나타난다.

 

👉 *DOM에 변화가 생기면, 렌더트리를 재생성하고 (그러면 모든 요소들의 스타일이 다시 계산됨) 레이아웃을 만들고 페인팅을 하는 과정이 다시 반복된다.*

복잡한 SPA(Single Page Application) 에서는 DOM 조작이 많이 발생한다. 그 뜻은 그 변화를 적용하기 위해 브라우저가 많이 연산을 해야한다는 말! 전체적인 프로세스를 비효율적으로 만든다.

이 부분에서 *Virtual DOM이 효율적*이다. 만약 뷰에 변화가 있다면, 그 변화는 실제 DOM 에 적용되기 전에 *가상의 DOM에 먼저 적용시키고 그 최종적인 결과를 실제 DOM으로 전달해준다.* 이로써, 브라우저 내에서 발생하는 *연산의 양을 줄이면서 성능이 개선*되는 것이다.



## 🔎 Virtual DOM(가상 DOM)

- ***UI의 이상적인 또는 “가상”적인 표현을 메모리에 저장**하고 ReactDOM과 같은 **라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념**이다.*

- 이 개념은 `React`에 의해 개척되었으며, Vue를 비롯해 다른 많은 프레임워크에 적용되었다.

- DOM을 가볍게 만든 JavaScript 표현이라고 할 수 있고 주로 React, Vue.js그리고 ELm에 사용된다.

  > `ELm` : 웹 브라우저 기반의 GUI(Graphical user interface)를 선언적으로 작성하기 위한 도메인 특화 언어

- 가상 DOM은 실제로 스크린에 랜더링하는 것이 아니기 때문에 DOM을 직접 업데이트하는것 보다 *상대적으로 빠르다.*

- 가상 DOM은 실제 DOM에서 처리하는 방식이 아닌 *Virtual DOM과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화하는 프로그래밍 개념*이다. 해당 DOM을 컴포넌트 단위로 쪼개어 HTML 컴포넌트 조림품처럼 다루는 개념.

  - DOM조작에 의한 랜더링이 비효율적인 문제를 해결.

  - SPA(Single Page Application)특징으로 DOM 복잡도 증가에 따른 최적화 및 유지 보수가 더 어려워지는 문제를 해결.

**👉 결론적으로 DOM을 반복적으로 직접 조작하면 그만큼 브라우저가 랜더링을 자주하게 되고 그만큼 PC자원을 많이 소모하게 되는 문제를 해결하기 위한 기술이다.**



### ❓ Virtual DOM이 변화를 어떻게 적용시키나

Virtual DOM은 **변화가 일어나면** 그 변화를 **오프라인 DOM 트리에 적용**시킨다. 이 DOM 트리는 렌더링도 되지 않기때문에 **연산 비용이 적다**. 연산이 끝나고 나면 그 **최종적인 변화를 실제 DOM에 던져준다.** 모든 변화를 하나로 묶어서 **딱 한번만** 한다. 그러면 레이아웃 계산과 리랜더링의 규모는 커지겠지만, 딱 한번만 한다는 것! 이렇게 하나로 묶어서 적용시키는것이, **연산의 횟수를 줄이는 것**.

예를 들어, React에서 state나 props가 갱신되면 render() 함수가 호출되어 새로운 앨리먼트(VDOM) 트리를 반환한다.

이때 효과적으로 UI를 갱신하기 위해서 **기존의 VDOM(Old virtual DOM)과 새로운 VDOM(Old virtual DOM)의 차이점을 찾아내어 변경된 부분만 새롭게 랜더링**한다.

즉, Virtual DOM은 DOM이 변경될 때마다 전체 DOM을 Reflow 하는 것이 아니라 

가상의 DOM을 이용하여 **한번만 Reflow를 수행**함으로 부하를 줄여 빠르게 그릴 수 있다.



✔️ 먼저 변화가 발생하면, `Vue`의 경우 변화가 필요한 곳만 추적해서 큐잉한다. `React`의 경우 컴포넌트를 렌더링하고 이펙트를 큐잉한다. 트리 비교를 통해 돔 조작을 하는데 이 프로세스를 "**patch**"(Vue)라고 하며 "**diffing**" 또는 "**reconciliation**"이라고도 한다.

#### ✅ React

1. **React의 Diffing Algorithm**

   > 일반적으로 기존의 DOM 트리를 새로운 트리로 변환하기 위하여 최소한의 연산을 하기위해서 최신 알고리즘을 사용하여도 n개의 노드가 있을때 O(n^3)의 복잡도를 가진다. 
   >
   > React는 2 가지 가정을 기반으로 O(n) 복잡도의 heuristic 알고리즘을 구현하였다. 
   >
   > 아래는 두가지 가정을 기반으로 알고리즘이 구현되었다.
   >
   > 1. **Two elements of differnt types will produce different trees.**
   >
   >    서로 다른 타입을 가진 두 엘리먼트는 다른 트리를 만들어 낸다.
   >
   > 2. **The developer can hit at which child elements may be stable across different renders with a key prop.**
   >
   >    개발자가 key prop를 통해 자식 엘리먼트의 변경 여부를 표시할 수 있다.
   >
   > https://react.dev/learn/preserving-and-resetting-state

2. **React Fiber**

   > 새로운 reconciliation algorighm
   >
   > https://github.com/acdlite/react-fiber-architecture

#### ✅ Vue

**Patch**

>  마운트 중에 사용된 의존성이 변경되면 이팩트가 다시 실행된다. 이번에는 업데이트된 새로운 가상 DOM 트리가 생성된다. 런타임 렌더러는 새 트리를 탐색하고 이전 트리와 비교하고 필요한 업데이트를 실제 DOM에 적용한다.
>
> [공식문서 참조](https://ko.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom)
>
> https://itchallenger.tistory.com/731



❕ 사실, 변화를 적용시키는 과정은 Virtual DOM이 없이도 이뤄질수 있다. *변화가 있을 때, 그 변화를 묶어서 DOM fragment 에 적용한 다음에 기존 DOM 에 던져주면 된다.*



### ❓ 그러면 Virtual DOM이 해결하려고 하는 것은 무엇? 

그 DOM fragment를 관리하는 과정을 수동으로 하나하나 작업 할 필요 없이, **자동화**하고 **추상화**한다. 그 뿐만 아니라, 만약에 이 작업을 직접 한다면, 기존 값 중 어떤게 바뀌었고 어떤게 바뀌지 않았는지 계속 파악하고 있어야하는데 (그렇지 않으면 수정 할 필요가 없는 DOM 트리도 업데이트를 하게 될 수도 있으니까), 이것도 Virtual DOM 이 자동으로 해준다. 어떤게 바뀌었는지 , 어떤게 바뀌지 않았는지 알아내준다.

마지막으로, DOM 관리를 Virtual DOM이 하도록 함으로써, 

*컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고*, 

*특정 DOM 을 조작할 것이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없습니다.* 

즉, **각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다**.





참고)

https://velopert.com/3236

https://rbals0445.tistory.com/62

https://itchallenger.tistory.com/757

