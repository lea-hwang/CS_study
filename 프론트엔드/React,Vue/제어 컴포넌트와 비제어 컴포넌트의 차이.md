# 제어 컴포넌트와 비제어 컴포넌트의 차이

## 🔎 제어 컴포넌트 (Controlled Component)

- 제어 컴포넌트는 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트한다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트다. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 “제어 컴포넌트 (controlled component)“라고 한다.

- *사용자의 입력을 받는 컴포넌트에 event 객체를 이용해 `setState()`로 값을 저장하는 방식을 제어 컴포넌트 방식*

  ```react
  export default function App() {
    const [input, setInput] = useState("");
    const onChange = (e) => {
      setInput(e.target.value);
    };
  
    return (
      <div className="App">
        <input onChange={onChange} />
      </div>
    );
  }
  ```

  

- 제어 컴포넌트는 사용자가 입력한 값과 저장되는 값이 실시간으로 동기화된다.

![img](https://velog.velcdn.com/images%2Fyukyung%2Fpost%2F9f93d492-f1e7-4768-9bdc-b2c3c7d6f10c%2FHoneycam%202021-05-11%2015-30-16.gif)

제어 컴포넌트의 값은 **항상 최신값**을 유지한다. 새로운 입력 값이 생길때 마다 상태를 새롭게 갱신한다. 이는 데이터와 UI에서 입력한 값이 항상 동기화된다.



## 🔎 비제어 컴포넌트 

- 기존의 바닐라 자바스크립트와 크게 다르지 않은 방식. 
  - 바닐라 자바스크립트를 사용할 때 폼을 제출할때 (submit button)을 클릭할 때 요소 내부의 값을 얻어왔다. 비제어 컴포넌트 또한 이와 유사한 방식으로 사용된다.

- 비제어 컴포넌트 방식을 사용할 땐, 제어 컴포넌트 방식에서 사용한 `setState()`를 쓰지 않고 `ref`(React에서 Dom을 직접 핸들링할 때 사용)를 사용해서 값을 얻는다.

  ```react
  export default function App() {
    const inputRef = useRef(); // ref 사용
    const onClick = () => {
      console.log(inputRef.current.value);
    };
  
    return (
      <div className="App">
        <input ref={inputRef} />
        <button type="submit" onClick={onClick}>
          전송
        </button>
      </div>
    );
  }
  ```

  

- 값이 실시간으로 동기화 되지 않는다. 
  - 만약 a와 b라는 컴포넌트가 있을 때, a에 대한 변화를 즉각적으로 b가 영향을 받아야 할때 비제어 컴포넌트는 이런 방식에 대한 대응을 할 수 없다.
  - 제어 컴포넌트의 경우 사용자가 입력을 하는 액션을 취할때마다 리렌더링을 발생시키는 반면, 
  - 비제어 컴포넌트는 사용자가 직접 트리거 하기 전까지는 리렌더링을 발생시키지도 않고 값을 동기화 시키지도 않는다.

![img](https://velog.velcdn.com/images%2Fyukyung%2Fpost%2F6c8405c3-f230-4d27-b1df-72e6c99b393c%2FHoneycam%202021-05-11%2015-32-01.gif)

필드에서 값을 트리거 해야 값을 얻을 수 있다. 사진에선 [전송] 버튼을 클릭하면 console에 값이 찍힌다. [전송]버튼을 클릭해 트리거 하기 전까지의 값은 변경되지 않는다.



### ❓ 왜 비제어 컴포넌트를 사용할 땐 useRef를 사용하고, useRef는 왜 리렌더링을 발생시키지 않는걸까?

1. useRef() 는 heap영역에 저장되는 일반적인 자바스크립트 객체이다.
2. 매번 렌더링할 때 동일한 객체를 제공한다. heap에 저장되어 있기 때문에 어플리케이션이 종료되거나 가비지 컬렉팅될 때까지, 참조할때마다 같은 메모리 값을 가진다고 할 수 있다.
3. 값이 변경되어도 리렌더링이 되지 않는다. 같은 메모리 주소를 갖고있기 때문에 자바스크립트의 === 연산이 항상 true 를 반환한다. 즉 변경사항을 감지할 수 없어서 리렌더링을 하지 않는다는 뜻이다.



### ❓ 제어 컴포넌트 언제 사용?

- 유효성 검사
- 유효한 데이터가 없는 경우 전송 버튼의 상태를 disabled로 표시하기
- 신용카드와 같은 특정 입력 방식 적용하기



### ❗ 제어 컴포넌트의 문제점

불필요한 리렌더링, 불필요한 api요청으로 인한 자원 낭비 문제로도 연결 될 수 있다.

이러한 불필요한 방법을 막기 위해 **스로틀링(throttle)**이나 **디바운싱 (debounce)**을 사용할 수 있다.

> `쓰로틀링` : 마지막 함수가 호출된 후 **일정 시간이 지나기 전에 다시 호출되지 않도록** 하는 것
> `디바운싱` : 연이어 호출되는 함수들 중 **마지막 함수(또는 제일 처음)만 호출**하도록 하는 것

일반적으로 모든 form 요소에서 상태의 동기화가 필요한 건 아니고, *form 요소가 증가할수록 모든 컴포넌트에 쓰로틀링이나 디바운싱을 걸기는 힘들다.* 만약 값이 트리거 된 이후에만 갱신이 돼도 문제가 없다면, ref를 사용하는 방식이 불필요한 렌더링을 방지하는데 더욱 도움이 될 수 있다. 이러한 비제어 컴포넌트를 사용해 렌더링을 최적화하는 라이브러리가 [react-hook-form](https://react-hook-form.com/)이다.



## 🔎 기능 : 제어 컴포넌트 vs 비제어 컴포넌트

- 즉각적으로, 실시간으로 값에 대한 피드백이 필요하다 => 제어 컴포넌트 사용
- 즉각적인 피드백이 불필요하고 제출시에만 값이 필요하다, 불필요한 렌더링과 값 동기화가 싫다 => 비제어 컴포넌트 사용

| 기능                                               | 제어 컴포넌트 | 비제어 컴포넌트 |
| -------------------------------------------------- | ------------- | --------------- |
| 일회성 정보 검색 (예: 제출)                        | O             | O               |
| 제출 시 값 검증                                    | O             | O               |
| 실시간으로 필드값의 유효성 검사                    | O             | X               |
| 조건부로 제출 버튼 비활성화 (disabled)             | O             | X               |
| 실시간으로 입력 형식 적용하기 (숫자만 가능하게 등) | O             | X               |
| 동적 입력                                          | O             | X               |





참고)

https://ko.reactjs.org/docs/forms.html#controlled-components

https://whales.tistory.com/126

https://velog.io/@yukyung/React-%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0