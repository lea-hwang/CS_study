# CI와 CD

## 🔎 CI

`빌드/테스트 자동화 과정` 

**개발자를 위한 자동화 프로세스인 `지속적인 통합(Continuous Integration)`**을 의미한다.

지속적 통합의 실행은 **소스/버전 관리 시스템에 대한 변경 사항을 정기적으로 커밋하여 모든 사람에게 동일 작업 기반을 제공**하는 것으로 시작한다.

**커밋할 때마다 빌드와 일련의 자동 테스트가 이루어져 동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장**한다.

CI/CD 파이프라인을 구현하기 위한 첫 번째 단계.



## 🔎 CD

`배포 자동화 과정`

`지속적인 서비스 제공(Continuous Delivery)` 또는 `지속적인 배포(Continuous Deployment)`를 의미한다.

두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다. 



### 지속적 제공(Continuous Delivery, CD)

CI의 빌드 자동화, 유닛 및 통합 테스트 수행 후, 이어지는 지속적 제공 프로세스에서는 **유효한 코드를 리포지토리에 자동으로 릴리스**한다. 그러므로 효과적인 지속적 제공 프로세스를 실현하기 위해서는 **개발 파이프라인에 CI가 먼저 구축**되어 있어야 한다. 지속적 제공의 **목표는 프로덕션 환경으로 배포할 준비가 되어 있는 코드베이스를 확보**하는 것이다.

지속적 제공의 경우, 코드 변경 사항 병합부터 프로덕션에 적합한 빌드 제공에 이르는 **모든 단계에는 테스트 자동화와 코드 릴리스 자동화가 포함**된다. 이 프로세스를 완료하면 운영팀이 더욱 빠르고 손쉽게 애플리케이션을 프로덕션으로 배포할 수 있게 된다.



### 지속적 배포(Continuous Deployment, CD)

CI/CD 파이프라인의 마지막 단계는 지속적 배포이다. 프로덕션 준비가 완료된 빌드를 코드 리포지토리에 자동으로 릴리스하는 **지속적 제공의 확장된 형태**인 지속적 배포는 **애플리케이션을 프로덕션으로 릴리스하는 작업을 자동화**한다. 프로덕션 이전의 파이프라인 단계에는 수동 작업 과정이 없으므로, 지속적 배포가 제대로 이루어지려면 **테스트 자동화가 제대로 설계**되어 있어야 한다.

실제 사례에서 지속적 배포란 개발자가 **애플리케이션에 변경 사항을 작성한 후 몇 분 이내에 클라우드 애플리케이션을 자동으로 실행할 수 있는 것**을 의미한다(자동화된 테스트를 통과한 것으로 간주). 이를 통해 **사용자 피드백을 지속적으로 수신하고 통합하는 일이 훨씬 수월**해진다. 이러한 모든 CI/CD 적용 사례는 **애플리케이션 배포의 위험성을 줄여**주므로 애플리케이션 변경 사항을 한 번에 모두 릴리스하지 않고 **작은 조각으로 세분화하여 더욱 손쉽게 릴리스할 수 있다**. 그러나 자동화된 테스트는 CI/CD 파이프라인의 여러 테스트 및 릴리스 단계를 수행할 수 있어야 하기 때문에 많은 선행 투자가 필요하다.

![img](https://blog.kakaocdn.net/dn/ckMQmf/btreLLPDmsL/toxwM0zsTV38PrftEhmbt1/img.png)



## 🔎 CI/CD 종류

- Jenkins

- CircleCI

- TravisCI

- Github Actions

- etc



## 🔎 CI/CD 적용 전후 비교

### 1. `CI/CD를 적용하기 전`의 고전적인 코드 통합 과정 : 

**1. 개발자들이 개발하여 코드를 수정한다.**

**2. 각자의 feature 브랜치에 코드를 push한다. (but, 어느 한 부분에서 에러가 났지만 개발자들은 눈치채지 못한다.)**

**3. 각자의 코드를 git에 올리고 통합(Intergration)한다.**

**4. 에러가 발생했지만 어느 부분에서 에러가 났는지 모르므로 다시 어디부분에 에러가 있는지 디버깅하고 코드를 수정한다.**

**5. (1) ~ (4)의 과정을 반복한다.**

**6. 많은 시간을 할애하여 에러가 해결되었으면 배포를 시작한다. 하지만 배포과정 또한, 개발자가 직접 배포과정을 거치므로 많은 시간을 소요한다.**

 

코드의 양이 적다면 조금만 시간을 할애해도 에러를 찾아낼 수 있지만, 코드의 양이 많다면 에러 추적이 안되므로 어마어마한 양의 디버깅 과정을 마주하게 될 수도 있다.

 

### 2. `CI/CD를 적용 후`의 과정 : 

(이 과정은 하나의 예시일 뿐 다르게 변경가능하다. 예를 들면 중간에 PR과정을 추가할 수 있고, sonarqube나 lint를 돌린다던지, git tag를 통해 Deploy를 Trigger 시킬 수 있다.) 

**1. 개발자들이 개발하여 feature브랜치에 코드를 push한다.**

**2. git push를 통해 Trigger되어 CI서버에서 알아서 Build, Test, Lint를 실행하고 결과를 전송한다.**

**3. 개발자들은 결과를 전송받고 에러가 난 부분이 있다면 에러부분을 수정하고 코드를 master 브랜치에 merge한다.**

**4. master 브랜치에 코드를 merge하고 Build, Test가 정상적으로 수행이 되었다면 CI서버에서 알아서 Deploy 과정을 수행한다.**

 

⚠️ *굳이 필요한 작업인가?* 

실무에서 일하며 일일히 빌드와 테스트, 배포과정을 개발자가 직접한다는 것은 리소스낭비이고 

심한 경우에는 업무의 대부분을 빌드와 테스트, 배포에 투자해야 할 수도 있다.

