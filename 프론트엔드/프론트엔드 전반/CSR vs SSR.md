# CSR(Client Side Rendering)과 SSR(Server Side Rendering)

## 🔎 CSR

**클라이언트쪽에서 렌더링이 일어난다.**

즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내주고, 클라이언트는 그것을 받아 렌더링을 시작한다.

![img](https://blog.kakaocdn.net/dn/Ek28V/btrFde42IHr/yb4wyWVcsqkV96kkrpS4Z0/img.png)

1. User가 Website 요청을 보냄.
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.
     
     > `CDN` : aws의 cloudflare를 생각하면 된다. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식. 데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크. 
3. 클라이언트는 HTML과 JS를 다운로드 받는다. **이때 SSR과 달리 유저는 아무것도 볼 수 없다**.
4. 생략
5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.
     (이때 유저들은 placeholder를 보게된다. )
6. 서버가 API로부터의 요청에 응답한다.
7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.



서버가 HTML 파일을 줄 때, 렌더가 준비가 된 파일이 아니다. **즉, HTML 파일 안에는 아무런 내용이 없다.** 그 내용은 JS 파일을 받아 실행을 시켜야 그제서야 만들어지는 것.

특히, index.html 파일의 바디 태그 안에 `<div id="root"></div>`와 같이 div 태그 하나만 덩그러니 있고 아무런 내용이 없는 것처럼 이렇게 아무것도 없는 상태로 전달되므로 유저는 아무것도 볼 수 없다.

```jsx
ReactDOM.render(<App />, document.getElementById('root'));
```

그러나 이후, 브라우저가 추가적으로 JS 파일을 다운받고 실행하면 그때 index.js에서 위와 같이 root 태그를 화면에 렌더링, 그려주게 되는 것입니다.

**반면에 SSR은 index.html 파일 내에 화면에 그려내는 코드들이 이미 작성되어 있기 때문에 CSR과 달리 페이지가 5단계에서 `Viewable`할 수 있다**. (SSR 아래 그림 참고)



#### 💡CDN (Content Delivery Network)

> - 지리적 제약 없이 전 세계 사용자에게 빠르고 안전하게 콘텐츠를 전송할 수 있는 콘텐츠 전송 기술.
> - 사용자 위치, 콘텐츠 원본 서버, [에지](https://www.alibabacloud.com/ko/knowledge/what-is-edge-computing) 서버 위치를 기준으로 콘텐츠(웹페이지, 동영상, 이미지)를 최종 사용자에게 전송할 수 있는 (에지 로케이션 서버라고도 하는) 분산 노드로 구성된 네트워크
>   - **CDN 노드**는 
>     - 콘텐츠를 캐싱할 수 있는 캐시 기능을 갖추고 있으며 
>     - 최종 사용자와 가까운 위치에서 사용자에게 콘텐츠를 제공할 수 있다. 
>     - CDN 제공업체에 의해 여러 지역에 구축되고 
>     - 여러 ISP(인터넷 서비스 제공자) 네트워크에 걸쳐 배포될 수 있다.
>
> - 서버와 사용자 사이의 물리적인 거리를 줄여 콘텐츠 로딩에 소요되는 시간을 최소화한다. 
> - 각 지역에 캐시 서버(PoP, Points of presence)를 분산 배치해, 근접한 사용자의 요청에 원본 서버가 아닌 캐시 서버가 콘텐츠를 전달한다. 
>   - 예를 들어, 미국에 있는 사용자가 한국에 호스팅 된 웹 사이트에 접근하는 경우 미국에 위치한 PoP 서버에서 웹사이트 콘텐츠를 사용자에게 전송하는 방식이다.
> - **CDN이 필요한 경우**
>   - 인터넷을 통해 비즈니스를 운영할 때
>   - 웹 사이트에서 그래픽 이미지, 동영상 파일 등의 콘텐츠를 제공할 때
>   - 특정 국가나 지역만을 타깃으로 하는 웹 서비스를 운영할 때는 CDN을 이용할 필요없다.
>     - 오히려 불필요한 연결 지점이 늘어나 웹 사이트의 성능 저하를 유발할 수 있다.
> - **CDN 활용 사례**
>   - 넷플릭스
>     - 넷플릭스의 서비스 범위가 전 세계에 걸쳐 있고, 구독자의 절반 이상이 미국 외의 지역에 분포하고 있어 콘텐츠를 안정적이고 빠르게 세계 각지로 전달할 필요 있어
>   - 에어비앤비
>     - 전 세계 고객에게 언제 어디서나 숙박 시설과 각종 액티비티를 예약할 수 있는 서비스 환경을 구축
>
> https://library.gabia.com/contents/infrahosting/8985/
>
> https://www.alibabacloud.com/ko/knowledge/what-is-cdn
>
> https://aws.amazon.com/ko/what-is/cdn/



## 🔎 SSR

**서버쪽에서 렌더링을 한다.**

요청할 때 즉시 만들어 -> 데이터가 달라짐 => 미리 만들어두기 어려운 페이지에 적합

> `렌더링` : 서버에서 **렌더될 준비를 끝마친 상태로 HTML 응답**을 브라우저(클라이언트)에 보내는 것
>
> - 브라우저의 렌더링 : **HTML, CSS, JavaScript 파일을 받아와 이를 읽고 파싱해서 실행한 결과물로 화면에 그려내는 과정**
> - 서버 사이드의 렌더링 : **HTML 파일 내에 내용이 있느냐 없느냐**. 내용이 있다면, 렌더링이 된 것.



![img](https://blog.kakaocdn.net/dn/ctbYqm/btrE8OfqPyZ/V89cr1aPQZemy8tNmnhLek/img.png)

1. User가 Website 요청을 보냄.

2. Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다.
   (리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)
3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다.

  그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.)

4. 클라이언트가 자바스크립트를 다운받는다.
5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다.
6. 브라우저가 Javascript 프레임워크를 실행한다.
7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.



HTML 파일 내에 내용이 모두 있으므로 브라우저는 바로 페이지를 렌더링 ➡️ 사용자에게 바로 보여짐 ➡️ 브라우저는 자바스크립트 파일을 다운로드 ➡️ 브라우저가 해당 파일을 실행 ➡️ **페이지의 상호작용이 가능**

**JS 파일은 읽히기 전**이므로 이를 다운로드 받아오면서 유저는 **컨텐츠를 볼 수 잇지만, 사이트를 조작할 수는 없**다. 이 때의 사용자 조작을 기억하고 있게 된다. 

JS까지 성공적으로 컴파일 되었다면, 기억하고 있던 사용자 조작이 실행되고, 이제 웹페이지는 상호작용이 가능해진다.



> **✔️ key point**
>
> Step5 : Viewable
> Step7 : Interactable



클라이언트(브라우저)가 데이터를 요청하면 그림의 순서대로 `브라우저`=>`프론트 서버`=>`백엔드 서버`=>`데이터베이스` 를 거쳐 데이터베이스에서 데이터를 가져온 후 다시 브라우저에 데이터가 그려지는 형식이다.
이 방식은 **서버에서 데이터까지 모두 포함하여 페이지를 구성**한 후 브라우저에 전달하는데

클라이언트가 페이지를 이동한다든가, 클릭으로 인한 다른 요청이 생길때마다 이 과정을 반복하기 때문에 화면에서 바뀌지 않아도 되는 부분도 계속해서 다시 렌더링되는 단점이 있다. 이는 곧 서버 부하 등의 문제를 일으킬 수 있다.

> 서버에서 페이지를 구성하여 반환한다.
> (단점) 불필요한 부분까지 다시 렌더링하게 된다.



## 🆚 CSR, SSR 차이

### 1. 웹 페이지를 로딩하는 시간

웹 페이지의 로딩의 종류는 1. 웹 사이트의 첫 페이지를 로딩하는 것과 2. 다른 나머지를 로딩하는 것이다.

- 첫 페이지 로딩 시간
  CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 **SSR은 필요한 부분의 HTML과 스크립트만 불러온다. => SSR이 더 빠름!**
- 나머지 페이지 로딩 시간
  첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정해보자. **CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔으므로 빠르다.** 반면, SSR은 첫 페이지를 로딩한 과정을 **정확하게 다시 실행**한다. 그래서 CSR이 SSR보다 빠르다.

### 2. SEO 대응

검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트를 읽어들인다. CSR은 JS를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 **JS가 실행되어야 metadata가 바뀐다**. 이렇게 이전 크롤러는 JS를 실행시키지 않았기 때문에 SEO 최적화가 필수적이었다. 그러나 구글이 이러한 이유로 JS 파일을 해석해서 내용을 찾아주기 시작했기 때문에 그 트렌드를 바꾸고 있다고 한다.

물론, **SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이**하다.

### 3. 서버 자원 사용

SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문.



## 🪄 사용 권장 예시

CSR, SSR은 각각의 장단점이 존재하기 때문에 적절한 상황에서 사용하면 된다.

**CSR**은 **네트워크가 빠르고, 서버의 성능이 좋지 않을 때** 사용할 수 있으며, 웹 어플리케이션에서 사용자와 상호작용할 것들이 많을 때나 사용자에게 보여줘야 하는 데이터의 양이 많을 때 로딩창을 띄울 수 있으므로 이러한 장점이 있다.

반대로 **SSR**은 CSR이 한번에 모든 것을 불러오는 것에 비해 SSR은 각 페이지마다 나눠 불러오므로 **네트워크가 느리거나, SEO가 필요할 때** 사용할 수 있을 것입니다. 또한, **웹 사이트가 상호작용이 별로 없다면** SSR을 적합하다.



## 🧙‍♂️ 두 문제를 해결한 Next.js

SSR의 단점 : 불필요한 부분까지 렌더링이 된다.
CSR의 단점 : 초기 진입 속도가 느리다. SEO에 취약하다.

위 두가지 단점을 해결하면서 두 방식의 장점을 살리는..!

**Next.js**라는 프레임워크가 생겼다. Next.js를 사용하여 **첫페이지는 백엔드 서버에서 렌더링하여 빈 html이 아닌 데이터가 채워진 html을 받아 검색최적화 문제를 해결**하고 **그 다음 페이지부턴 CSR방식을 적용하여 필요한 데이터 부분만 갱신해 서버의 부하도 줄이게** 한 것이다.

Next.js의 기능은 리액트로도 구현이 가능하지만 러닝커브가 있는 편이다.

> Next.js는 리액트의 SSR을 쉽게 구현해주는 프레임워크다.
> 실무에선 SSR과 Code Splitting 기능을 꼭 넣어 작업하도록!





참고자료)

https://tecoble.techcourse.co.kr/post/2021-09-10-ssr/